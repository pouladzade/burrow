// Copyright 2017 Monax Industries Limited
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package test

import (
	"encoding/hex"
	"testing"

	"strings"

	. "github.com/hyperledger/burrow/binary"
	"github.com/hyperledger/burrow/execution/errors"
	"github.com/hyperledger/burrow/execution/evm"
	"github.com/hyperledger/burrow/execution/evm/abi"
	"github.com/hyperledger/burrow/execution/evm/asm/bc"
	"github.com/hyperledger/burrow/execution/evm/sha3"
	"github.com/hyperledger/burrow/permission"
	"github.com/stretchr/testify/assert"
)

// Compiling the Permissions solidity contract at
// (generated by with 'make snatives' function) and passing to
// https://ethereum.github.io/browser-solidity (toggle details to get list)
// yields:
// Keep this updated to drive TestPermissionsContractSignatures
const compiledSigs = `
4670dc12 hasPermissions(address,uint64)
ccc2936e setPermissions(address,uint64)
30f69812 unsetPermissions(address,uint64)
`

func TestPermissionsContractSignatures(t *testing.T) {
	contract := evm.SNativeContracts()["Permissions"]

	nFuncs := len(contract.Functions())

	sigMap := idToSignatureMap()

	assert.Len(t, sigMap, nFuncs,
		"Permissions contract defines %s functions so we need %s "+
			"signatures in compiledSigs",
		nFuncs, nFuncs)

	for funcID, signature := range sigMap {
		assertFunctionIDSignature(t, contract, funcID, signature)
	}
}

func TestSNativeContractDescription_Dispatch(t *testing.T) {
	contract := evm.SNativeContracts()["Permissions"]
	caller := getAccount(t, "alice")
	grantee := getAccount(t, "bob")

	function, err := contract.FunctionByName("hasPermissions")
	if err != nil {
		t.Fatalf("Could not get function: %s", err)
	}
	funcID := function.ID()

	// Should fail since we have no permissions
	retValue, err := contract.Dispatch(bc1State, caller, bc.MustSplice(funcID[:],
		grantee.Address(), permissionsToWord256(permission.CreateAccount)), &defaultGas, nopLogger)
	if !assert.Error(t, err, "Should fail due to lack of permissions") {
		return
	}
	assert.IsType(t, err, errors.LacksSNativePermission{})

	// Grant all permissions and dispatch should success
	caller.SetPermissions(permission.AllAccountPermissions)
	retValue, err = contract.Dispatch(bc1State, caller, bc.MustSplice(funcID[:],
		grantee.Address().Word256(), permissionsToWord256(permission.CreateAccount)), &defaultGas, nopLogger)
	assert.NoError(t, err)
	assert.Equal(t, retValue, LeftPadBytes([]byte{1}, 32))
}

func TestSNativeContractDescription_Address(t *testing.T) {
	contract := evm.NewSNativeContract("A comment",
		"CoolButVeryLongNamedContractOfDoom")
	assert.Equal(t, sha3.Sha3(([]byte)(contract.Name))[12:], contract.Address().Bytes())
}

//
// Helpers
//
func assertFunctionIDSignature(t *testing.T, contract *evm.SNativeContractDescription,
	funcIDHex string, expectedSignature string) {
	fromHex := funcIDFromHex(t, funcIDHex)
	function, err := contract.FunctionByID(fromHex)
	assert.NoError(t, err,
		"Error retrieving SNativeFunctionDescription with ID %s", funcIDHex)
	if err == nil {
		assert.Equal(t, expectedSignature, function.Signature())
	}
}

func funcIDFromHex(t *testing.T, hexString string) abi.FunctionSelector {
	bs, err := hex.DecodeString(hexString)
	assert.NoError(t, err, "Could not decode hex string '%s'", hexString)
	if len(bs) != 4 {
		t.Fatalf("FunctionSelector must be 4 bytes but '%s' is %v bytes", hexString,
			len(bs))
	}
	return abi.FirstFourBytes(bs)
}

func permissionsToWord256(permissions permission.Permissions) Word256 {
	return Uint64ToWord256(uint64(permissions))
}

// turns the solidity compiler function summary into a map to drive signature
// test
func idToSignatureMap() map[string]string {
	sigMap := make(map[string]string)
	lines := strings.Split(compiledSigs, "\n")
	for _, line := range lines {
		trimmed := strings.Trim(line, " \t")
		if trimmed != "" {
			idSig := strings.Split(trimmed, " ")
			sigMap[idSig[0]] = idSig[1]
		}
	}
	return sigMap
}
